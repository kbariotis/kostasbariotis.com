{"data":{"file":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAVABQDASIAAhEBAxEB/8QAGQABAQADAQAAAAAAAAAAAAAAAAQBAgUD/8QAFgEBAQEAAAAAAAAAAAAAAAAAAwIB/9oADAMBAAIQAxAAAAGXEfnO2KxXytBY6QBP/8QAGxAAAgIDAQAAAAAAAAAAAAAAAQIDEQASIiH/2gAIAQEAAQUC2qMsrDRjkh7U+9ZIKYC8jNp//8QAFxEBAAMAAAAAAAAAAAAAAAAAAAEQIf/aAAgBAwEBPwFlQ//EABkRAAEFAAAAAAAAAAAAAAAAAAABECExQf/aAAgBAgEBPwGWwWz/xAAbEAACAgMBAAAAAAAAAAAAAAAAEQEhAxAxgf/aAAgBAQAGPwK2dsYo5BBWReaRB//EABwQAAICAwEBAAAAAAAAAAAAAAERACExQVFhcf/aAAgBAQABPyHzg5KmRyuAZAwYJ2aHFOw5Qmlybntx2y3CnEl/Z//aAAwDAQACAAMAAAAQOyi8/8QAGBEAAwEBAAAAAAAAAAAAAAAAAAERMUH/2gAIAQMBAT8QUXCB6YR//8QAGhEAAgIDAAAAAAAAAAAAAAAAAAERMSFBsf/aAAgBAgEBPxByVkzvonYxY//EAB0QAQEAAwACAwAAAAAAAAAAAAERACFBMVFhcbH/2gAIAQEAAT8Q6uhuUW+P3HKhIpbqr8JMNj2KrvBpVoF3uLYUDX3imLRSGt4ck1onhy7wNT0XD24jIs1n/9k=","aspectRatio":0.9657118055555556,"src":"/static/avatar-820706df6fdb07a9b021a790449fec17-381d6.jpg","srcSet":"/static/avatar-820706df6fdb07a9b021a790449fec17-62f05.jpg 200w,\n/static/avatar-820706df6fdb07a9b021a790449fec17-dc2b4.jpg 400w,\n/static/avatar-820706df6fdb07a9b021a790449fec17-381d6.jpg 800w,\n/static/avatar-820706df6fdb07a9b021a790449fec17-e5d70.jpg 1200w,\n/static/avatar-820706df6fdb07a9b021a790449fec17-d14e0.jpg 1600w,\n/static/avatar-820706df6fdb07a9b021a790449fec17-9cc71.jpg 2225w","srcWebp":"/static/avatar-820706df6fdb07a9b021a790449fec17-fefde.webp","srcSetWebp":"/static/avatar-820706df6fdb07a9b021a790449fec17-5eed2.webp 200w,\n/static/avatar-820706df6fdb07a9b021a790449fec17-68e3c.webp 400w,\n/static/avatar-820706df6fdb07a9b021a790449fec17-fefde.webp 800w,\n/static/avatar-820706df6fdb07a9b021a790449fec17-300fe.webp 1200w,\n/static/avatar-820706df6fdb07a9b021a790449fec17-ed5bd.webp 1600w,\n/static/avatar-820706df6fdb07a9b021a790449fec17-9442a.webp 2225w","sizes":"(max-width: 800px) 100vw, 800px"}}},"site":{"siteMetadata":{"title":"Kostas Bariotis' Blog","description":"Senior full stack engineer <a href=\"https://geekbot.io\">@geekbot_io</a>, co-organizer of <a href=\"https://devitconf.org\">@devitconf</a> & <a href=\"https://www.meetup.com/Thessaloniki-Node-js-Meetup/\">@skgnodejs</a>, host of <a href=\"http://devastation.tv\">Devastation Podcast</a>.","siteUrl":"https://kostasbariotis.com"}},"mainPost":{"html":"<p>I have been working with a serverless architecture for the past one year. We have gone full serverless on the project we are currently working on and after a lot of research and trial and error, I came up with a pattern of organizing such an architecture. This post will be an attempt to explain this approach and how it came to be.\nThis post won't go deep on how various Serverless providers works and I certainly wont try to convince you to adopt it. My goal is to share my solution with you and ask for your feedback. I hope that my expirience will help somebody.</p>\n<h2 id=\"no-servers-really\"><a href=\"#no-servers-really\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>No servers? Really?</h2>\n<p>Let's start with the elephant in the room. Serverless doesn't mean \"no servers\".</p>\n<img src=\"https://media.giphy.com/media/j2nATOAdRgYZq/giphy.gif\" alt=\"Serverless doesn&apos;t mean no servers\">\n<p>It simply means that you don't have to worry about them. On my mind, serverless is another layer on top of the famous PaaS platforms. We are doing a step away from hiding the machines's specifics by hiding your application's specifics, such as the process management and the routing.</p>\n<p>Ofcourse, you would still have to worry about databases and other components of your stack. But you can be sure that your code will always be running and not be tighted to one process that can bring your whole application down.</p>\n<h2 id=\"functions\"><a href=\"#functions\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Functions</h2>\n<p>Taking the servers away, what have you left with? Code. Organized in functions. Thus the famous \"functions\" name you are seeing here and there.</p>\n<p>Functions can be anything. Let's see an example:</p>\n<p>Imagine a simple Node.js app with a router, two controllers attached to certain paths that call some models and return. We have two functions on that app and some bootstrap code. Remove the router and you are only left with two functions.</p>\n<p>Let's try to do this the serverless way. I will be using AWS and the famous <a href=\"http://serverless.com\" target=\"_blank\" rel=\"noreferrer noopener\">serverless</a> framework. All we need for the example above are the two controllers and a serverless configuration file:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\">\n      <pre class=\"language-yml\"><code class=\"language-yml\">service: serverless-example\n\nprovider:\n  name: aws\n  runtime: nodejs4.3\n  environment:\n    DYNAMODB_TABLE: ${self:service}-${opt:stage, self:provider.stage}\n\nfunctions:\n  create:\n    handler: users/register.handler\n    events:\n      - http: POST /users\n  login:\n    handler: users/login.handler\n    events:\n      - http:\n          path: POST /users/login\n\nresources:\n  Resources:\n    UsersDynamoDbTable:\n      Type: &#39;AWS::DynamoDB::Table&#39;\n      DeletionPolicy: Retain\n      Properties:\n        AttributeDefinitions:\n          -\n            AttributeName: id\n            AttributeType: S\n        KeySchema:\n          -\n            AttributeName: id\n            KeyType: HASH\n        ProvisionedThroughput:\n          ReadCapacityUnits: 1\n          WriteCapacityUnits: 1\n        TableName: ${self:provider.environment.DYNAMODB_TABLE}</code></pre>\n      </div>\n<p>The configuration is pretty straightforward. We want the AWS provider with the node4.3 runtime. Two AWS Lambda functions each tight to a certail API Gateway path and a DynamoDB table described as a Clouformation resource object. After this gets deployed, API Gateway will respond back with an AWS URL (e.g.: <a href=\"https://some-random-id.api.aws.com\" target=\"_blank\" rel=\"noreferrer noopener\">https://some-random-id.api.aws.com</a>) that we can hit to reach our two controllers.</p>\n<p>And there you go. That's all it takes to create an API. Awesome, right?</p>\n<p>With the ability to create so many functions in a gif, we could end up very fast in a hell that none knows where anything goes. This is where the Micro Functions architecture comes in. But before we dive into that, let's take a look and understand how AWS runs our code.</p>\n<h2 id=\"combining-the-pieces\"><a href=\"#combining-the-pieces\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Combining the pieces</h2>\n<p>Essentially, the way to go about this, and the way AWS Lambdas works, is to spin up a instance for your functions each time an event arises and run those predefined functions. Routing and the exposure to the outside world is being handled by the API Gateway which will raise an event each time someone hits your endpoint and route it to the specific Lambda Function. So when you hit <code class=\"language-text\">https://some-random-id.api.aws.com/users/login</code> from the outside, an instance will be created and run the handler you have defined above.</p>\n<p>The instance (that may be new(cold state) or may have been up for a while(hot state)) will start and run the function using the payload passed to API Gateway. It will then return the results back to API Gateway and it will pass it back to the client. That's really all there is in a serverless architecture.</p>\n<p>The big question ofcourse here, is whether the cold/hot state is significant enough to prevent you from even thinking about getting into it. Truth is that I haven't seen any major latency, but it could also mean that there is a latency that we chose to not give attention to.</p>\n<h2 id=\"the-micro-functions-architecture\"><a href=\"#the-micro-functions-architecture\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The Micro Functions architecture</h2>\n<p>Our project started growing quickly and became hard to test and add features to.</p>\n<p>This style is derived by two major patterns, the microservices and the serverless architecture. The goal is to organize a codebase in a way that can support adding new features with ease, that is easily testable and can be managable and deployable with single terminal commands.</p>\n<p>Microservices architecture is able to deliver all of the above (when done correctly) by splitting up the architecture in smaller, isolated services. Each service hide its internals by exposing a single API that allows other services to communicate with it. The communication protocol must be well defined and respected by all others.</p>\n<p>What this architecture desribes is to divide your codebase into smaller services much like in a microservices architecture but to let each service to expose serverless functions instead of an entire application.</p>\n<h3 id=\"boundaries\"><a href=\"#boundaries\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Boundaries</h3>\n<p>Each of these services handles a part of your business logic and doesnt share its internals with the others. They can be tested and deployed in isolation without affecting the others, much like in the microservices world.</p>\n<h3 id=\"communication\"><a href=\"#communication\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Communication</h3>\n<p>The communication between these may be direct by calling each other or in an event based architecture through a message broker. Again, both of these are valid and in my experience both can work very well.</p>\n<h3 id=\"responsibility\"><a href=\"#responsibility\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Responsibility</h3>\n<p>The responsibility for each Micro Function is up to you to decide. You can host an entire API in one function or have once function per action in a classic CRUD style.</p>\n<p>An example:</p>\n<p>Articles Service\n|\n| - Exposes a Micro Function called <code class=\"language-text\">API</code> that handles routing whether you want to fetch one Article or fetch all</p>\n<p>Comments Service\n|\n| - Exposes a Micro Function called <code class=\"language-text\">getComment</code> that fetches one Comment\n| - Exposes a Micro Function called <code class=\"language-text\">getComments</code> that fetches all Comments\n| - Exposes a Micro Function called <code class=\"language-text\">getCommentsForArticle</code> that fetches all Comments for an Article</p>\n<p><a href=\"https://serverless.com/blog/serverless-architecture-code-patterns/\" target=\"_blank\" rel=\"noreferrer noopener\">Both of these styles</a> are valid and it's up to you to decide</p>\n<h3 id=\"testing\"><a href=\"#testing\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Testing</h3>\n<p>Testing</p>\n<h2 id=\"final-words\"><a href=\"#final-words\" aria-hidden=\"true\" class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Final words</h2>\n<p>It seems like all of the majors infrastructure providers have invest a lot in the serverless infrastructure services. It may be something that will revoluniotize the way we build applications but certainly has a long way to go and reach the maturity of the current systems.</p>\n<p>For us over at Quotelier, has served us great so far. It's cost effective and allows the developers to act on the infrastructure in a way that we can be sure that it won't bring everything down. We are not in the need of hiring a dedicated DevOps guy and we certainly don't feel like missing something. For the record, here are some pros and cons, we have found:</p>\n<p>Pros:</p>\n<ul>\n<li>Cost effective: Over 100 AWS Lambdas and the cost is still zero (fact is that we are not yet in the actual user base size we would like to be)</li>\n<li>Auto-scaling: We basically don't worry much about it</li>\n<li>DevOps out of the box</li>\n</ul>\n<p>Cons:</p>\n<ul>\n<li>Vendor lock-in:</li>\n<li>Not exactly simpler: Having less DevOps to do doesnt neccesarily means it's simpler. You still need basic knowledge of how things not only to be able to spin up an architecture like this but also to do it in the right way.</li>\n<li>Development experience is still.. mehh</li>\n</ul>\n<p><a href=\"https://serverless.com/blog/serverless-conf-2017-nyc-recap/\" target=\"_blank\" rel=\"noreferrer noopener\">https://serverless.com/blog/serverless-conf-2017-nyc-recap/</a></p>","excerpt":"I have been working with a serverless architecture for the past one year. We have gone full serverless on the project we are currentlyâ€¦","frontmatter":{"date":"October 04, 2017","path":"/drafts/the-microfunctions-architecture/","tags":null,"title":"The Microfunctions architecture","draft":true}},"nextPost":{"html":"","excerpt":"","frontmatter":{"date":"March 10, 2017","path":"/drafts/microservices-lets-talk-about-boundaries/","tags":"MicroServices","title":"Microservices: lets talk about boundaries","draft":true}}},"pageContext":{"jsonName":"drafts-the-microfunctions-architecture-cd0","internalComponentName":"ComponentDraftsTheMicrofunctionsArchitecture","path":"/drafts/the-microfunctions-architecture/","component":"/home/travis/build/kbariotis/kostasbariotis.com/src/templates/blog-post.js","componentChunkName":"component---src-templates-blog-post-js","context":{"mainPostPath":"/drafts/the-microfunctions-architecture/","nextPostPath":"/drafts/microservices-lets-talk-about-boundaries/"},"updatedAt":1529439934332,"pluginCreator___NODE":"Plugin default-site-plugin","pluginCreatorId":"Plugin default-site-plugin","componentPath":"/home/travis/build/kbariotis/kostasbariotis.com/src/templates/blog-post.js","mainPostPath":"/drafts/the-microfunctions-architecture/","nextPostPath":"/drafts/microservices-lets-talk-about-boundaries/"}}